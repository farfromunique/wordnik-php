<?php
/**
 *  Copyright 2011 Wordnik, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/**
 *
 * NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
 */

/**
 *
 * NOTE: This has been updated from the version created by Swagger, to mesh with PSR-4 and be installable by composer.
 * 
 * The update was done by Aaron Coquet (aaron@acwpd.com) in 2017.
 */
namespace wordnik;

class WordsApi {

	function __construct(APIClient $apiClient) {
		$this->apiClient = $apiClient;
	}

	/**
	 * searchWords
	 * Searches words
	 * query, string: Search query (required)
	 * includePartOfSpeech, string: Only include these comma-delimited parts of speech (optional)
	 * excludePartOfSpeech, string: Exclude these comma-delimited parts of speech (optional)
	 * caseSensitive, string: Search case sensitive (optional)
	 * minCorpusCount, int: Minimum corpus frequency for terms (optional)
	 * maxCorpusCount, int: Maximum corpus frequency for terms (optional)
	 * minDictionaryCount, int: Minimum number of dictionary entries for words returned (optional)
	 * maxDictionaryCount, int: Maximum dictionary definition count (optional)
	 * minLength, int: Minimum word length (optional)
	 * maxLength, int: Maximum word length (optional)
	 * skip, int: Results to skip (optional)
	 * limit, int: Maximum number of results to return (optional)
	 * @return WordSearchResults
	 */

	 public function searchWords(string $query, string $includePartOfSpeech='', string $excludePartOfSpeech='', bool $caseSensitive=true, int $minCorpusCount=5, int $maxCorpusCount=-1, int $minDictionaryCount=1, int $maxDictionaryCount=-1, int $minLength=1, int $maxLength=-1, int $skip=0, int $limit=10) {

		//parse inputs
		$resourcePath = "/words.{format}/search/{query}";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		$queryParams['caseSensitive'] = $this->apiClient->toQueryValue($caseSensitive);
		$queryParams['includePartOfSpeech'] = $this->apiClient->toQueryValue($includePartOfSpeech);
		$queryParams['excludePartOfSpeech'] = $this->apiClient->toQueryValue($excludePartOfSpeech);
		$queryParams['minCorpusCount'] = $this->apiClient->toQueryValue($minCorpusCount);
		$queryParams['maxCorpusCount'] = $this->apiClient->toQueryValue($maxCorpusCount);
		$queryParams['minDictionaryCount'] = $this->apiClient->toQueryValue($minDictionaryCount);
		$queryParams['maxDictionaryCount'] = $this->apiClient->toQueryValue($maxDictionaryCount);
		$queryParams['minLength'] = $this->apiClient->toQueryValue($minLength);
		$queryParams['maxLength'] = $this->apiClient->toQueryValue($maxLength);
		$queryParams['skip'] = $this->apiClient->toQueryValue($skip);
		$queryParams['limit'] = $this->apiClient->toQueryValue($limit);
		$resourcePath = str_replace("{" . "query" . "}", $this->apiClient->toPathValue($query), $resourcePath);

		//make the API Call
		if (! isset($body)) {
			$body = array();
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);

		if(! $response){
			return null; // TODO: Throw error, instead.
		}

		$responseObject = $this->apiClient->deserialize($response, 'WordSearchResults');
		return $responseObject;

	}
	/**
	 * getWordOfTheDay
	 * Returns a specific WordOfTheDay
	 * date, string: Fetches by date in yyyy-MM-dd (optional)
	 * @return WordOfTheDay
	 */

	 public function getWordOfTheDay($date=null) {

		//parse inputs
		$resourcePath = "/words.{format}/wordOfTheDay";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		if($date != null) {
			$queryParams['date'] = $this->apiClient->toQueryValue($date);
		}
		//make the API Call
		if (! isset($body)) {
			$body = array();
		}
		$response = $this->apiClient->callAPI($resourcePath, $method,
																					$queryParams, $body,
																					$headerParams);


		if(! $response){
				return null; // TODO: Throw error, instead.
			}

		$responseObject = $this->apiClient->deserialize($response,
																										'WordOfTheDay');
		return $responseObject;

	}
	/**
	 * reverseDictionary
	 * Reverse dictionary search
	 * query, string: Search term (required)
	 * findSenseForWord, string: Restricts words and finds closest sense (optional)
	 * includeSourceDictionaries, string: Only include these comma-delimited source dictionaries (optional)
	 * excludeSourceDictionaries, string: Exclude these comma-delimited source dictionaries (optional)
	 * includePartOfSpeech, string: Only include these comma-delimited parts of speech (optional)
	 * excludePartOfSpeech, string: Exclude these comma-delimited parts of speech (optional)
	 * expandTerms, string: Expand terms (optional)
	 * sortBy, string: Attribute to sort by (optional)
	 * sortOrder, string: Sort direction (optional)
	 * minCorpusCount, int: Minimum corpus frequency for terms (optional)
	 * maxCorpusCount, int: Maximum corpus frequency for terms (optional)
	 * minLength, int: Minimum word length (optional)
	 * maxLength, int: Maximum word length (optional)
	 * includeTags, string: Return a closed set of XML tags in response (optional)
	 * skip, string: Results to skip (optional)
	 * limit, int: Maximum number of results to return (optional)
	 * @return DefinitionSearchResults
	 */

	 public function reverseDictionary(string $query, string $findSenseForWord='', string $includeSourceDictionaries='', string $excludeSourceDictionaries='', string $includePartOfSpeech='', string $excludePartOfSpeech='', string $expandTerms='', string $sortBy='', string $sortOrder='desc', int $minCorpusCount=5, int $maxCorpusCount=-1, int $minLength=1, int $maxLength=-1, bool $includeTags=false, int $skip=0, int $limit=10): DefinitionSearchResults {

		//parse inputs
		$resourcePath = "/words.{format}/reverseDictionary";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		$queryParams['query'] = $this->apiClient->toQueryValue($query);
		$queryParams['findSenseForWord'] = $this->apiClient->toQueryValue($findSenseForWord);
		$queryParams['includeSourceDictionaries'] = $this->apiClient->toQueryValue($includeSourceDictionaries);
		$queryParams['excludeSourceDictionaries'] = $this->apiClient->toQueryValue($excludeSourceDictionaries);
		$queryParams['includePartOfSpeech'] = $this->apiClient->toQueryValue($includePartOfSpeech);
		$queryParams['excludePartOfSpeech'] = $this->apiClient->toQueryValue($excludePartOfSpeech);
		$queryParams['minCorpusCount'] = $this->apiClient->toQueryValue($minCorpusCount);
		$queryParams['maxCorpusCount'] = $this->apiClient->toQueryValue($maxCorpusCount);
		$queryParams['minLength'] = $this->apiClient->toQueryValue($minLength);
		$queryParams['maxLength'] = $this->apiClient->toQueryValue($maxLength);
		$queryParams['expandTerms'] = $this->apiClient->toQueryValue($expandTerms);
		$queryParams['includeTags'] = $this->apiClient->toQueryValue($includeTags);
		$queryParams['sortBy'] = $this->apiClient->toQueryValue($sortBy);
		$queryParams['sortOrder'] = $this->apiClient->toQueryValue($sortOrder);
		$queryParams['skip'] = $this->apiClient->toQueryValue($skip);
		$queryParams['limit'] = $this->apiClient->toQueryValue($limit);
		
		//make the API Call
		if (! isset($body)) {
			$body = array();
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);

		if(! $response){
			return null; // TODO: Throw error, instead.
		}

		$responseObject = $this->apiClient->deserialize($response, 'DefinitionSearchResults');
		return $responseObject;

	}
	/**
	 * getRandomWords
	 * Returns an array of random WordObjects
	 * includePartOfSpeech, string: CSV part-of-speech values to include (optional)
	 * excludePartOfSpeech, string: CSV part-of-speech values to exclude (optional)
	 * sortBy, string: Attribute to sort by (optional)
	 * sortOrder, string: Sort direction (optional)
	 * hasDictionaryDef, string: Only return words with dictionary definitions (optional)
	 * minCorpusCount, int: Minimum corpus frequency for terms (optional)
	 * maxCorpusCount, int: Maximum corpus frequency for terms (optional)
	 * minDictionaryCount, int: Minimum dictionary count (optional)
	 * maxDictionaryCount, int: Maximum dictionary count (optional)
	 * minLength, int: Minimum word length (optional)
	 * maxLength, int: Maximum word length (optional)
	 * limit, int: Maximum number of results to return (optional)
	 * @return array[WordObject]
	 */

	 public function getRandomWords(string $includePartOfSpeech='', string $excludePartOfSpeech='', string $sortBy='', string $sortOrder='desc', string $hasDictionaryDef='false', int $minCorpusCount=0, int $maxCorpusCount=-1, int $minDictionaryCount=1, int $maxDictionaryCount=-1, int $minLength=5, int $maxLength=-1, int $limit=10): array {

		//parse inputs
		$resourcePath = "/words.{format}/randomWords";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		$queryParams['hasDictionaryDef'] = $this->apiClient->toQueryValue($hasDictionaryDef);
		if (! $includePartOfSpeech === '') {
			$queryParams['includePartOfSpeech'] = $this->apiClient->toQueryValue($includePartOfSpeech);
		}
		if (! $excludePartOfSpeech === '') {
			$queryParams['excludePartOfSpeech'] = $this->apiClient->toQueryValue($excludePartOfSpeech);
		}
		if (! $sortBy === '') {
			$queryParams['sortBy'] = $this->apiClient->toQueryValue($sortBy);
		}
		$queryParams['minCorpusCount'] = $this->apiClient->toQueryValue($minCorpusCount);
		$queryParams['maxCorpusCount'] = $this->apiClient->toQueryValue($maxCorpusCount);
		$queryParams['minDictionaryCount'] = $this->apiClient->toQueryValue($minDictionaryCount);
		$queryParams['maxDictionaryCount'] = $this->apiClient->toQueryValue($maxDictionaryCount);
		$queryParams['minLength'] = $this->apiClient->toQueryValue($minLength);
		$queryParams['maxLength'] = $this->apiClient->toQueryValue($maxLength);
		$queryParams['sortOrder'] = $this->apiClient->toQueryValue($sortOrder);
		$queryParams['limit'] = $this->apiClient->toQueryValue($limit);
		
		
		//make the API Call
		if (! isset($body)) {
			$body = array();
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);

		if(! $response){
			return null; // TODO: Throw error, instead.
		}

		$responseObject = $this->apiClient->deserialize($response, 'array[WordObject]');
		return $responseObject;

	}
	/**
	 * getRandomWord
	 * Returns a single random WordObject
	 * includePartOfSpeech, string: CSV part-of-speech values to include (optional)
	 * excludePartOfSpeech, string: CSV part-of-speech values to exclude (optional)
	 * hasDictionaryDef, string: Only return words with dictionary definitions (optional)
	 * minCorpusCount, int: Minimum corpus frequency for terms (optional)
	 * maxCorpusCount, int: Maximum corpus frequency for terms (optional)
	 * minDictionaryCount, int: Minimum dictionary count (optional)
	 * maxDictionaryCount, int: Maximum dictionary count (optional)
	 * minLength, int: Minimum word length (optional)
	 * maxLength, int: Maximum word length (optional)
	 * @return WordObject
	 */

	 public function getRandomWord(string $includePartOfSpeech='', string $excludePartOfSpeech='', int $hasDictionaryDef=0, int $minCorpusCount=0, int $maxCorpusCount=-1, int $minDictionaryCount=1, int $maxDictionaryCount=-1, int $minLength=5, int $maxLength=-1): WordObject {

		//parse inputs
		$resourcePath = "/words.{format}/randomWord";
		$resourcePath = str_replace("{format}", "json", $resourcePath);
		$method = "GET";
		$queryParams = array();
		$headerParams = array();

		$queryParams['hasDictionaryDef'] = $this->apiClient->toQueryValue($hasDictionaryDef);
		$queryParams['includePartOfSpeech'] = $this->apiClient->toQueryValue($includePartOfSpeech);
		$queryParams['excludePartOfSpeech'] = $this->apiClient->toQueryValue($excludePartOfSpeech);
		$queryParams['minCorpusCount'] = $this->apiClient->toQueryValue($minCorpusCount);
		$queryParams['maxCorpusCount'] = $this->apiClient->toQueryValue($maxCorpusCount);
		$queryParams['minDictionaryCount'] = $this->apiClient->toQueryValue($minDictionaryCount);
		$queryParams['maxDictionaryCount'] = $this->apiClient->toQueryValue($maxDictionaryCount);
		$queryParams['minLength'] = $this->apiClient->toQueryValue($minLength);
		$queryParams['maxLength'] = $this->apiClient->toQueryValue($maxLength);
		
		//make the API Call
		if (! isset($body)) {
			$body = array();
		}
		$response = $this->apiClient->callAPI($resourcePath, $method, $queryParams, $body, $headerParams);


		if(! $response){
			return null; // TODO: Throw error, instead.
		}

		$responseObject = $this->apiClient->deserialize($response, 'WordObject');
		return $responseObject;

	}

}

